[manifest]
version = "1.0.0"
dump_lua = true
priority = 0

# some help from Cryptid 
[[patches]]
[patches.pattern]
target = "game.lua"
pattern = "self.GAME.starting_deck_size = #G.playing_cards"
position = "before"
payload = '''
 if G.GAME.modifiers.hpot_all_sticker then
     local tab = {}
     for k, v in pairs(SMODS.Stickers) do
        if k ~= "pinned" and k ~= "hpot_nuke" and k~= "hpot_jtem_mood" and k ~= "hpot_mail" and k ~= "hpot_cannibal" and k ~= "hpot_binary" and k ~= "hpot_book" and k ~= "eternal" then
            tab[#tab+1] = k
        end
      end
      for k, v in pairs(G.playing_cards) do
          local k = pseudorandom_element(tab)
          SMODS.Stickers[k]:apply(v,true)
      end
 end
'''
match_indent = true

# unreleated but this patch is ONLY and ONLY for blunder, which is a blunder
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/game_object.lua"]'
pattern = '''
            card.ability[self.key] = val
            if val and self.config and next(self.config) then
                card.ability[self.key] = {}
                for k, v in pairs(self.config) do
                    if type(v) == 'table' then
                        card.ability[self.key][k] = copy_table(v)
                    else
                        card.ability[self.key][k] = v
                    end
                end
            end
        end
'''
position = 'before'
payload = '''
	if val == false and card.ability[self.key] then
        card = card
        if self and self.removed then
        card:remove_sticker_calc(self, card)
        end
    else
        card = card
        if self and self.applied then
        card:apply_sticker_calc(self, card)
        end
    end
'''
match_indent = false


# Add mod badge
# Apparently, this is taken from Papeback
[[patches]]
[patches.pattern]
target = "functions/UI_definitions.lua"
pattern = "badges.mod_set = nil"
position = "before"
payload = '''
for k, v in pairs(SMODS.Stickers) do
  if card and card.ability and k ~= "hpot_jtem_mood" and card.ability[k] and G.your_collection then
    for i = 1, #G.your_collection do
        if card.area == G.your_collection[i] then
            SMODS.create_mod_badges(SMODS.Stickers[k], badges)
        end
    end
  end
end
'''
match_indent = true

# Cannot discard eternals

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = "table.insert(cards, G.hand.highlighted[i])"
position = "at"
payload = '''
if not G.hand.highlighted[i].ability.eternal then
    table.insert(cards, G.hand.highlighted[i])
end
'''
match_indent = true

[[patches]]
[patches.pattern]
target = "functions/state_events.lua"
pattern = '''
for i=1, highlighted_count do
            G.hand.highlighted[i]:calculate_seal({discard = true})
            local removed = false
            local effects = {}
            SMODS.calculate_context({discard = true, other_card =  G.hand.highlighted[i], full_hand = G.hand.highlighted, ignore_other_debuff = true}, effects)
            SMODS.trigger_effects(effects)
            for _, eval in pairs(effects) do
                if type(eval) == 'table' then
                    for key, eval2 in pairs(eval) do
                        if key == 'remove' or (type(eval2) == 'table' and eval2.remove) then removed = true end
                    end
                end
            end
            if not G.hand.highlighted[i].ability.eternal then
                table.insert(cards, G.hand.highlighted[i])
            end
            if removed then
                destroyed_cards[#destroyed_cards + 1] = G.hand.highlighted[i]
                if SMODS.shatters(G.hand.highlighted[i]) then
                    G.hand.highlighted[i]:shatter()
                else
                    G.hand.highlighted[i]:start_dissolve()
                end
            else 
                G.hand.highlighted[i].ability.discarded = true
                draw_card(G.hand, G.discard, i*100/highlighted_count, 'down', false, G.hand.highlighted[i])
            end
        end
'''
position = "at"
payload = '''
for i=1, highlighted_count do
if not G.hand.highlighted[i].ability.eternal then
            G.hand.highlighted[i]:calculate_seal({discard = true})
            local removed = false
            local effects = {}
            SMODS.calculate_context({discard = true, other_card =  G.hand.highlighted[i], full_hand = G.hand.highlighted, ignore_other_debuff = true}, effects)
            SMODS.trigger_effects(effects)
            for _, eval in pairs(effects) do
                if type(eval) == 'table' then
                    for key, eval2 in pairs(eval) do
                        if key == 'remove' or (type(eval2) == 'table' and eval2.remove) then removed = true end
                    end
                end
            end
            if not G.hand.highlighted[i].ability.eternal then
                table.insert(cards, G.hand.highlighted[i])
            end
            if removed then
                destroyed_cards[#destroyed_cards + 1] = G.hand.highlighted[i]
                if SMODS.shatters(G.hand.highlighted[i]) then
                    G.hand.highlighted[i]:shatter()
                else
                    G.hand.highlighted[i]:start_dissolve()
                end
            else 
                G.hand.highlighted[i].ability.discarded = true
                draw_card(G.hand, G.discard, i*100/highlighted_count, 'down', false, G.hand.highlighted[i])
            end
        end
    end
'''
match_indent = true

# Perishable trigger twice fix

[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/game_object.lua"]'
pattern = '''
            if context.end_of_round and not context.repetition and not context.individual then
                card:calculate_perishable()
            end
'''
position = 'at'
payload = '''
        if card.ability.set == "Default" or card.ability.set == "Enhanced" then
            if context.end_of_round and not card.hpot_temp_check then
                card.hpot_temp_check = true
                card:calculate_perishable()
            end
        elseif context.end_of_round and not context.repetition and not context.individual then
            card:calculate_perishable()
        end

'''
match_indent = false

# Rental trigger twice fix
[[patches]]
[patches.pattern]
target = '=[SMODS _ "src/game_object.lua"]'
pattern = '''
            if context.end_of_round and not context.repetition and not context.individual then
                card:calculate_rental()
            end
'''
position = 'at'
payload = '''
        if card.ability.set == "Default" or card.ability.set == "Enhanced" then
            if context.end_of_round and not card.hpot_temp_check then
                card.hpot_temp_check = true
                card:calculate_rental()
            end
        elseif context.end_of_round and not context.repetition and not context.individual then
            card:calculate_rental()
        end

'''
match_indent = false

